PARSER_BEGIN(Lugosi)
import java.io.*;
public class Lugosi {

  public static void main(String args[]) throws ParseException,IOException {
    
 Lugosi analisador = new Lugosi(new FileInputStream(args[0]));
 analisador.Lugosi();
  }

}

PARSER_END(Lugosi)

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

TOKEN :
{
  <MAIN: "main">
| <ACHAVES: "{">
| <FCHAVES: "}">
| <APAR: "(">
| <FPAR: ")">
| <VOID: "void">
| <FLOATCHAVE: "float">
| <BOOL: "bool">
| <ELCHAVE: ";">
| <ATTCHAVE: ":=">
| <LET: "let">
| <WHILE: "while">
| <DO: "do">
| <IF: "if">
| <DEF: "def">
| <READ: "readIO">
| <RETURN: "return">
| <PRINT: "printIO">
| <SUM: "+">
| <SUB: "-">
| <MULT: "*">
| <DIV: "/">
| <AND: "&&">
| <OR: "||">
| <SYMHIGHER: ">">
| <SYMLOWER: "<">
| <EQUAL: "==">
| <SEP: ",">

}

TOKEN :
{
  <TOKEN_NUM : (["0"-"9"])*["."](["0"-"9"])*((["E"])(["+"]|["-"])(["0"-"9"])*)*>
 |<TOKEN_ID: ["a"-"z","A"-"Z"] ( ["a"-"z","A"-"Z","0"-"9"])* (["_"])*(["a"-"z","A"-"Z","0"-"9"])*>

}


// LUGOSI -> MAIN FUNC?
void Lugosi () :
{}
{
 Main() (Func())?
<EOF> 
}

// MAIN -> "void" "main" "{" VARDECL SEQCOMANDOS "}"
void Main () :
{}
{
 <VOID> <MAIN> <ACHAVES> Vardecl() SeqComandos() <FCHAVES> 
}

// VARDECL -> VARDECL "let" TIPO TOKEN_id ";" | vazio
//TODO RESOLVER RECURSOES A ESQUERDA
void Vardecl() :
{}
{
  (Vardecl() <LET> Type() <TOKEN_ID> <ELCHAVE>)?
}

// TIPO -> "float" | "bool" | "void"
void Type() :
{}
{
  (<FLOATCHAVE>) | (<BOOL>) | <VOID>
}

// SEQCOMANDOS -> SEQCOMANDOS COMANDO | vazio
//TODO RESOLVER RECURSOES A ESQUERDA
void SeqComandos() :
{}
{
  (SeqComandos() Comando())?
}

// COMANDO -> TOKEN_id ":=" EXP ";"
// | TOKEN_id "(" LISTAEXP? ")" ";"
// | "if" EXP "{" SEQCOMANDOS "}" ";"
// | "while" EXP "do" "{" SEQCOMANDOS "}" ";"
// | TOKEN_id ":=" "readIO" "(" ")"
// | "return" EXP ";"
// | "printIO" EXP ";"

void Comando() :
{}
{
  (<TOKEN_ID> <ATTCHAVE> Exp() <ELCHAVE>) | (<TOKEN_ID> <APAR> (ListExp())? <FPAR> <ELCHAVE>)
| (<IF> Exp() <ACHAVES> SeqComandos() <FCHAVES> <ELCHAVE>) | (<WHILE> Exp() <DO> <ACHAVES> SeqComandos() <FCHAVES> <ELCHAVE>)
| (<TOKEN_ID> <ATTCHAVE> <READ> <APAR> <FPAR>) | (<RETURN> Exp() <ELCHAVE>) | (<PRINT> Exp() <ELCHAVE>)
  
}

// EXP -> "(" EXP OP EXP ")" | FATOR
void Exp() :
{}
{
  (<APAR> Exp() Op() Exp() <FPAR>) | Fator()
}
// FATOR -> TOKEN_id | TOKEN_id "(" LISTAEXP? ")"
// | TOKEN_numliteral | "true" | "false"
void Fator() :
{}
{
  (<TOKEN_ID>) | (<TOKEN_ID> <APAR> (ListExp())? <FPAR>)
}
// OP ->  "+" | "-" | "*" | "/" | "&&" | "||" | "<" | ">" | "=="
void Op() :
{}
{
  <SUM> | <SUB> | <MULT> | <DIV> | <AND> | <OR> | <SYMLOWER> | <SYMHIGHER> | <EQUAL>
  
}

// LISTAEXP -> EXP | LISTAEXP "," EXP
//TODO RESOLVER RECURSOES A ESQUERDA
void ListExp() :
{}
{
  Exp() | (ListExp() <SEP> Exp())
}

// FUNC -> FUNC "def" TIPO TOKEN_id "(" LISTAARG? ")" "{" VARDECL SEQCOMANDOS "}"
//| "def" TIPO TOKEN_id "(" LISTAARG? ")" "{" VARDECL SEQCOMANDOS "}"
//TODO RESOLVER RECURSOES A ESQUERDA
void Func() :
{}
{
  (Func() <DEF> Type() <TOKEN_ID> <APAR> (ListaArg())? <FPAR> <ACHAVES> Vardecl() SeqComandos() <FCHAVES>)
| (<DEF> Type() <TOKEN_ID> <APAR> (ListaArg())? <FPAR> <ACHAVES> Vardecl() SeqComandos() <FCHAVES>)

  
}
// LISTAARG -> TIPO TOKEN_id | LISTAARG "," TIPO TOKEN_id
//TODO RESOLVER RECURSOES A ESQUERDA
void ListaArg() :
{}
{
 (Type() <TOKEN_ID>) | (ListaArg() <SEP> Type() <TOKEN_ID>)
  
}




