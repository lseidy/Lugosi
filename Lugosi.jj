PARSER_BEGIN(Lugosi)
import java.io.*;

public class Lugosi {

  public static void main(String args[]) throws ParseException,IOException {
    
 Lugosi analisador = new Lugosi(new FileInputStream(args[0]));
 analisador.Lugosi();
  }

}

PARSER_END(Lugosi)

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

TOKEN :
{
  <MAIN: "main">
| <ACHAVES: "{">
| <FCHAVES: "}">
| <APAR: "(">
| <FPAR: ")">
| <VOID: "void">
| <FLOATCHAVE: "float">
| <BOOL: "bool">
| <ELCHAVE: ";">
| <ATTCHAVE: ":=">
| <LET: "let">
| <WHILE: "while">
| <DO: "do">
| <IF: "if">
| <DEF: "def">
| <READ: "readIO">
| <RETURN: "return">
| <PRINT: "printIO">
| <SUM: "+">
| <SUB: "-">
| <MULT: "*">
| <DIV: "/">
| <AND: "&&">
| <OR: "||">
| <SYMHIGHER: ">">
| <SYMLOWER: "<">
| <EQUAL: "==">
| <SEP: ",">
| <TRUE: "true">
| <FALSE: "false">

}

TOKEN :
{
  <TOKEN_NUM : (["0"-"9"])+(["."](["0"-"9"])+)?((["E"])(["+"]|["-"])?(["0"-"9"])+)?>
 |<TOKEN_ID: ["a"-"z","A"-"Z"] ( ["a"-"z","A"-"Z","0"-"9"])* (["_"] (["a"-"z","A"-"Z","0"-"9"])+)*>
 //|<TOKEN_ID: ["a"-"z","A"-"Z"] (["a"-"z","A"-"Z"] | ["0"-"9"])* (["_"])*(["a"-"z","A"-"Z","0"-"9"])+>

}


// LUGOSI -> MAIN FUNC?
Prog Lugosi () :
{Main main; ArrayList<Func> array=null;}
{
 main=Main() (array=Func())?
 {return new Prog(main,array);}
<EOF> 
}

// MAIN -> "void" "main" "{" VARDECL SEQCOMANDOS "}"
Main Main () :
{ArrayList<VarDecl> vars=null,ArrayList<SeqComandos> coms=null}
{
 <VOID> <MAIN> <ACHAVES> vars=Vardecl() coms=SeqComandos() <FCHAVES> 

 {return new Main(vars,coms);}
}

// VARDECL -> VARDECLRE
// VARDECLRE -> "let" TIPO TOKEN_id ";" VARDECLRE | vazio
ArrayList<VarDecl> Vardecl() :
{ArrayList<VarDecl> vars = new ArrayList(), String tipo; Token id;}
{
  (<LET> tipo=Type() id=<TOKEN_ID> <ELCHAVE> { vars.add(new VarDecl(tipo,id.image));})*
  { return vars;}
}

// TIPO -> "float" | "bool" | "void"
void Type() :
{}
{
  (<FLOATCHAVE>) | (<BOOL>) | <VOID>
}

// SEQCOMANDOS -> SEQCOMANDOS COMANDO | vazio
void SeqComandos(Arraylist<SeqComandos>):
{Comando c;}
{
  c = (Comando() {SeqComandos.add(c);})*
}

// COMANDO -> TOKEN_id ":=" EXP ";"
// | TOKEN_id "(" LISTAEXP? ")" ";"
// | "if" EXP "{" SEQCOMANDOS "}" ";"
// | "while" EXP "do" "{" SEQCOMANDOS "}" ";"
// | TOKEN_id ":=" "readIO" "(" ")"
// | "return" EXP ";"
// | "printIO" EXP ";"

// COMANDO -> TOKEN_ID COMANDO_FAC |"if" EXP "{" SEQCOMANDOS "}" ";"
// |"while" EXP "do" "{" SEQCOMANDOS "}" ";" || "return" EXP ";" | | "printIO" EXP ";"
// COMANDO_FAC -> ":=" EXP ";" | "(" LISTAEXP? ")" ";" | ":=" "readIO" "(" ")"

void Comando() :
{}
{
  <TOKEN_ID>  Comando_Fac() 
| <IF> Exp() <ACHAVES> SeqComandos() <FCHAVES> <ELCHAVE>
| <WHILE> Exp() <DO> <ACHAVES> SeqComandos() <FCHAVES> <ELCHAVE>
| <RETURN> Exp() <ELCHAVE>
| <PRINT> Exp() <ELCHAVE>
}

// ATT -> ":=" ATT_FAC | "("LISTEXP?")" ";"
// ATT_FAC -> EXP ";" | READ ()

void Comando_Fac():
{}
{
  <ATTCHAVE> Att()
| <APAR> (ListExp())? <FPAR> <ELCHAVE>
}

void Att():
{}
{
  Exp() <ELCHAVE>
| <READ> <APAR> <FPAR> 
}

// EXP -> "(" EXP OP EXP ")" | FATOR
void Exp() :
{}
{
  (<APAR> Exp() Op() Exp() <FPAR>) | Fator()
}

// FATOR -> TOKEN_id FATOR_FAC | TOKEN_numliteral | "true" | "false"
// FATOR_FAC -> "(" LISTAEXP? ")" | vazio
void Fator() :
{}
{
  <TOKEN_ID> Fator_Fac()| <TOKEN_NUM> | <TRUE> | <FALSE>
}
void Fator_Fac():
{}
{
  (<APAR> (ListExp())? <FPAR>)?
}

// OP ->  "+" | "-" | "*" | "/" | "&&" | "||" | "<" | ">" | "=="
void Op() :
{}
{
  <SUM> | <SUB> | <MULT> | <DIV> | <AND> | <OR> | <SYMLOWER> | <SYMHIGHER> | <EQUAL>
  
}

// LISTAEXP -> EXP | LISTAEXP "," EXP
//TODO RESOLVER RECURSOES A ESQUERDA - FEITO
// LISTAEXP -> "," EXP LISTAEXP_RE
// LISTAEXP_RE -> EXP LISTAEXP | vazio

void ListaExp()
{}
{
  Exp() (<SEP> Exp())* 
}
 
// FUNC -> "def" TIPO TOKEN_id "(" LISTAARG? ")" "{" VARDECL SEQCOMANDOS "}" FUNC_RE
// FUNC_RE -> "def" TIPO TOKEN_id "(" LISTAARG? ")" "{" VARDECL SEQCOMANDOS "}" FUNC_RE | vazio

void Func() :
{}
{
  (<DEF> Type() <TOKEN_ID> <APAR> (ListaArg())? <FPAR> <ACHAVES> Vardecl() SeqComandos() <FCHAVES>)+ 
}

// LISTAARG -> TIPO TOKEN_id | LISTAARG "," TIPO TOKEN_id
//TODO RESOLVER RECURSOES A ESQUERDA
//LISTAARG -> TIPO TOKEN_id LISTAARG_RE
//LISTAARG_RE -> "," TIPO TOKEN_id | vazio

void ListaArg() :
{}
{
 Type() <TOKEN_ID> (<SEP> Type() <TOKEN_ID>)*
}